<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>y00ts NFT Finder</title>
    <style>
        /* CSS Styles remain largely the same */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            margin: 20px;
            background-color: red;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.5;
        }
        .container {
            background-color: red;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            text-transform: uppercase;
            color: white;
        }

        .header-image-container {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
            max-width: 100%;
        }
        #headerImage {
            max-width: 100%;
            height: auto;
            display: block;
        }
        .header-link-overlay {
            position: absolute;
            display: block;
            border-radius: 50%;
            z-index: 5;
        }
        #headerLinkTwitter {
            top: 65%;
            left: 9%;
            width: 10%;
            height: 18%;
        }
        #headerLinkY00ts {
            top: 65%;
            left: 26%;
            width: 10%;
            height: 18%;
        }


        .search-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        input[type="number"] {
            padding: 10px;
            border: 1px solid #ff8080;
            border-radius: 4px;
            flex: 1 1 auto;
            min-width: 150px;
            box-sizing: border-box;
            font-size: 1rem;
            text-transform: none;
            background-color: #cc0000;
            color: white;
        }
        input[type="number"]::placeholder {
            text-transform: uppercase;
            color: #ffcccc;
        }

        button, .action-button {
            padding: 10px 15px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            font-size: 1rem;
            white-space: nowrap;
        }
        button:active, .action-button:active {
            transform: translateY(1px);
        }

        #searchBtn, #toggleFeatureBtn, #downloadBtn {
            background-color: #0D98BA;
        }
        #searchBtn:hover, #toggleFeatureBtn:hover, #downloadBtn:hover {
            background-color: #0A7A9A;
        }

        #resetAppBtn {
            background-color: #f0ad4e;
        }
        #resetAppBtn:hover {
            background-color: #ec971f;
        }

        #toggleFeatureBtn {
            margin-bottom: 20px;
            font-size: 1em;
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: fit-content;
            padding: 10px 15px;
        }
         #toggleFeatureBtn.off {
            background-color: #f0ad4e;
        }
        #toggleFeatureBtn.off:hover {
            background-color: #ec971f;
        }
        #toggleFeatureBtn.on {
            background-color: #5cb85c;
        }
        #toggleFeatureBtn.on:hover {
            background-color: #4cae4c;
        }

        #result {
            margin-top: 10px;
        }

        .image-stack-container {
            position: relative;
            width: 100%;
            max-width: 350px;
            aspect-ratio: 1 / 1;
            margin: 15px auto;
            border-radius: 8px;
            overflow: hidden;
        }

        .image-stack-container img {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 8px;
            object-fit: contain;
            pointer-events: none;
        }

        #nftImage {
            position: relative;
            z-index: 1;
            border: 1px solid #ff8080;
        }

        #cigarOverlayImage { z-index: 3; }

        .error, .overlay-error {
            color: #ffff00;
            margin-top: 10px;
            font-size: 0.9em;
        }
        .loading {
            margin-top: 10px;
            font-style: italic;
            color: white;
        }
        #downloadBtn {
            display: block;
            width: -moz-fit-content;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            margin-top: 20px;
        }
    </style>

</head>
<body>

<div class="container">
    <div class="header-image-container">
        <img id="headerImage" src="" alt="Y00TS NFT FINDER HEADER"> <!-- src will be set by JS -->
        <a id="headerLinkTwitter" class="header-link-overlay" href="https://x.com/y00tsNFT" target="_blank" rel="noopener noreferrer" aria-label="Visit y00ts on X"></a>
        <a id="headerLinkY00ts" class="header-link-overlay" href="https://www.y00ts.com/" target="_blank" rel="noopener noreferrer" aria-label="Visit y00ts.com"></a>
    </div>

    <div class="search-controls">
        <input type="number" id="y00tIdInput" placeholder="YOUR Y00T ID" min="1" max="15000">
        <button id="searchBtn">SEARCH</button>
        <button id="resetAppBtn">RESET</button>
    </div>

    <button id="toggleFeatureBtn" class="off">CIGAR</button>

    <div id="result">
        <div id="loading" class="loading" style="display:none;">LOADING DATA...</div>
        <div id="error" class="error"></div>

        <div id="imageStackContainer" class="image-stack-container" style="display: block;">
            <img id="nftImage" src="" alt="PREVIEW Y00T IMAGE"> <!-- src will be set by JS -->
            <img id="cigarOverlayImage" src="" alt="Cigar Overlay" style="display:none;"> <!-- src will be set by JS -->
        </div>
        <p id="cigarError" class="overlay-error" style="display:none;"></p>
        <button id="downloadBtn" class="action-button" style="display:none;">DOWNLOAD IMAGE</button>
    </div>
</div>

<script>
    // --- State Variables ---
    let showCigar = false;
    let lastFetchedMetadata = null;

    // --- AbortController ---
    let currentFetchController = null;

    // --- Load IDs ---
    // Use objects to pass by reference for load IDs if needed, or manage them carefully.
    // For simplicity here, we'll manage incrementing IDs.
    let currentNftImageLoadId = 0;
    let currentCigarLoadId = 0;
    let currentHeaderImageLoadId = 0; // For the header image

    // Store blob URLs to revoke them later
    let currentNftImageBlobUrl = null;
    let currentCigarBlobUrl = null;
    let currentHeaderBlobUrl = null;
    let currentPreviewBlobUrl = null;


    // --- Constants ---
    const HEADER_IMAGE_URL = "https://raw.githubusercontent.com/zio06/degods/refs/heads/assets/header.png";
    const PREVIEW_IMAGE_URL = "https://raw.githubusercontent.com/zio06/degods/refs/heads/assets/preview%20y00ts.png";
    const PREVIEW_IMAGE_ALT = "PREVIEW Y00T IMAGE";

    // --- DOM Element References ---
    const y00tIdInput = document.getElementById('y00tIdInput');
    const searchBtn = document.getElementById('searchBtn');
    const resetAppBtn = document.getElementById('resetAppBtn');
    const toggleFeatureBtn = document.getElementById('toggleFeatureBtn');
    const imageStackContainer = document.getElementById('imageStackContainer');
    const nftImage = document.getElementById('nftImage');
    const cigarOverlayImage = document.getElementById('cigarOverlayImage');
    const headerImage = document.getElementById('headerImage');
    const errorDiv = document.getElementById('error');
    const cigarError = document.getElementById('cigarError');
    const loadingDiv = document.getElementById('loading');
    const downloadBtn = document.getElementById('downloadBtn');

    // --- Helper: Load image as Blob and set src to ObjectURL ---
    async function loadImageAsBlob(imgElement, imageUrl, altText, currentLoadIdRef, successCallback, errorCallback) {
        const localLoadId = ++currentLoadIdRef.id; // Increment and use local copy

        // Revoke previous blob URL for this specific image element if it exists
        if (imgElement._currentBlobUrl) {
            URL.revokeObjectURL(imgElement._currentBlobUrl);
            imgElement._currentBlobUrl = null;
        }
        
        // Clear src immediately to prevent brief flash of old image if styling changes display
        imgElement.src = ""; 
        imgElement.alt = altText || "Loading image...";

        try {
            const response = await fetch(imageUrl, {
                signal: currentFetchController ? currentFetchController.signal : null,
                mode: 'cors' // Important for fetching external resources
            });
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
            }
            const blob = await response.blob();

            if (currentLoadIdRef.id !== localLoadId) {
                console.log(`Old image load (${altText}) aborted (ID mismatch).`);
                URL.revokeObjectURL(URL.createObjectURL(blob)); // Clean up unused blob
                return;
            }

            const blobUrl = URL.createObjectURL(blob);
            imgElement._currentBlobUrl = blobUrl; // Store for later revocation
            imgElement.src = blobUrl;
            imgElement.alt = altText;

            imgElement.onload = () => {
                if (currentLoadIdRef.id === localLoadId) { // Check ID again on load
                    console.log(`${altText} loaded successfully via blob.`);
                    if (successCallback) successCallback();
                } else {
                     URL.revokeObjectURL(blobUrl); // Clean up if race condition led to this
                     imgElement._currentBlobUrl = null;
                }
            };
            imgElement.onerror = () => {
                if (currentLoadIdRef.id === localLoadId) { // Check ID again on error
                    console.error(`Failed to load image ${altText} from blob URL.`);
                    URL.revokeObjectURL(blobUrl);
                    imgElement._currentBlobUrl = null;
                    if (errorCallback) errorCallback();
                }
            };

        } catch (err) {
            if (err.name === 'AbortError') {
                console.log(`Image fetch for ${altText} aborted.`);
            } else {
                console.error(`Error fetching ${altText} as blob:`, err);
            }
            if (currentLoadIdRef.id === localLoadId && errorCallback) errorCallback();
        }
    }


    // --- Event Listeners ---
    searchBtn.addEventListener('click', fetchY00t);
    resetAppBtn.addEventListener('click', resetSearch);

    toggleFeatureBtn.addEventListener('click', () => {
        showCigar = !showCigar;
        toggleFeatureBtn.classList.toggle('off', !showCigar);
        toggleFeatureBtn.classList.toggle('on', showCigar);
        updateCigarVisibility();
    });

    downloadBtn.addEventListener('click', handleDownload);

    y00tIdInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            fetchY00t();
        }
    });

    // --- UI Update Functions ---
    function revokeBlobUrl(blobUrl) {
        if (blobUrl) {
            URL.revokeObjectURL(blobUrl);
        }
    }
    
    function clearImageElement(imgElement) {
        if (imgElement._currentBlobUrl) {
            URL.revokeObjectURL(imgElement._currentBlobUrl);
            imgElement._currentBlobUrl = null;
        }
        imgElement.src = '';
        imgElement.alt = '';
        imgElement.style.display = 'none';
        imgElement.onload = null;
        imgElement.onerror = null;
    }


    function showPreviewNftImage() {
        imageStackContainer.style.display = 'block';
        const loadIdRef = { id: currentNftImageLoadId }; // Pass as object for reference
        loadImageAsBlob(
            nftImage,
            PREVIEW_IMAGE_URL,
            PREVIEW_IMAGE_ALT,
            loadIdRef,
            () => { currentNftImageLoadId = loadIdRef.id; }, // Update global on success
            () => {
                nftImage.alt = "Error loading preview";
                imageStackContainer.style.display = 'none';
            }
        );
    }

    function clearFetchedDataUI(showPreview = false) {
        clearImageElement(nftImage);
        clearImageElement(cigarOverlayImage);
        
        if (showPreview) {
            showPreviewNftImage();
        } else {
            imageStackContainer.style.display = 'none';
        }

        downloadBtn.style.display = 'none';
        errorDiv.textContent = '';
        cigarError.textContent = '';
        cigarError.style.display = 'none';
        loadingDiv.style.display = 'none';
        lastFetchedMetadata = null;
    }


    function resetSearch() {
        if (currentFetchController) {
            currentFetchController.abort();
            currentFetchController = null;
        }
        currentNftImageLoadId++; // Invalidate previous loads
        currentCigarLoadId++;   // Invalidate previous loads

        y00tIdInput.value = '';
        clearFetchedDataUI(true); // Show preview

        showCigar = false;
        toggleFeatureBtn.classList.add('off');
        toggleFeatureBtn.classList.remove('on');

        if (document.activeElement !== y00tIdInput) {
             y00tIdInput.focus();
        }
    }

    function updateCigarVisibility() {
        const canShow = showCigar && lastFetchedMetadata && imageStackContainer.style.display !== 'none';
        displayOverlayImage(lastFetchedMetadata, canShow);
    }

    function displayOverlayImage(metadata, shouldShowExplicitly) {
        const imgElement = cigarOverlayImage;
        const errorElement = cigarError;
        const baseUrl = `https://raw.githubusercontent.com/zio06/degods/refs/heads/y00ts-cigar/`;
        const fileNamePartConstructor = (traitVal) => `${encodeURIComponent(traitVal)}.png`;
        const errorMessagePrefix = `"CIGAR"`;
        
        const loadIdRef = { id: currentCigarLoadId }; // Pass as object

        if (!shouldShowExplicitly) {
            clearImageElement(imgElement);
            errorElement.style.display = 'none';
            errorElement.textContent = '';
            return;
        }
        
        errorElement.style.display = 'none';
        errorElement.textContent = '';

        if (!metadata || !metadata.attributes || !Array.isArray(metadata.attributes) || metadata.attributes.length === 0) {
            console.warn(`NO METADATA OR ATTRIBUTES ON NFT FOR ${errorMessagePrefix} VARIANT.`);
            clearImageElement(imgElement);
            return;
        }

        const relevantAttribute = metadata.attributes.find(
            attr => attr.trait_type && attr.trait_type.toLowerCase() === "fur"
        );

        if (relevantAttribute && relevantAttribute.value) {
            const attributeValue = relevantAttribute.value;
            const fileNamePart = fileNamePartConstructor(attributeValue);
            const imageUrl = baseUrl + fileNamePart;

            console.log(`Attempting to load cigar overlay via blob: ${imageUrl}`);
            imgElement.style.display = 'block'; // Show it so loading indicator might be visible if CSS handles it
            loadImageAsBlob(
                imgElement,
                imageUrl,
                `Cigar Overlay for ${attributeValue}`,
                loadIdRef,
                () => { // Success
                    currentCigarLoadId = loadIdRef.id;
                    imgElement.style.display = 'block';
                    errorElement.style.display = 'none';
                },
                () => { // Error
                    clearImageElement(imgElement);
                    console.error(`${errorMessagePrefix} VARIANT FOR TRAIT "${attributeValue.toUpperCase()}" NOT FOUND OR FAILED TO LOAD. URL: ${imageUrl}.`);
                    // Optionally show error message in UI:
                    // errorElement.textContent = `${errorMessagePrefix} for ${attributeValue} not available.`;
                    // errorElement.style.display = 'block';
                }
            );
        } else {
            clearImageElement(imgElement);
            console.warn(`REQUIRED ATTRIBUTE ("FUR") NOT FOUND FOR THIS NFT TO APPLY ${errorMessagePrefix}.`);
        }
    }

    async function fetchY00t() {
        const idValueTrimmed = y00tIdInput.value.trim();

        if (currentFetchController) {
            currentFetchController.abort();
        }
        currentFetchController = new AbortController();
        const { signal } = currentFetchController;

        // Increment IDs to invalidate any ongoing loads for the *previous* search
        currentNftImageLoadId++;
        currentCigarLoadId++;

        if (!idValueTrimmed) {
            clearFetchedDataUI(true);
            errorDiv.textContent = 'PLEASE ENTER A Y00T ID.';
            loadingDiv.style.display = 'none';
            if (currentFetchController && currentFetchController.signal === signal) currentFetchController = null;
            return;
        }

        clearFetchedDataUI(false);
        loadingDiv.style.display = 'block';
        errorDiv.textContent = '';

        const id = parseInt(idValueTrimmed);

        if (isNaN(id) || id < 1 || id > 15000) {
            errorDiv.textContent = 'PLEASE ENTER A VALID ID (BETWEEN 1 AND 15000).';
            loadingDiv.style.display = 'none';
            clearFetchedDataUI(true);
            if (currentFetchController && currentFetchController.signal === signal) currentFetchController = null;
            return;
        }

        const metadataIndex = id - 1;
        const metadataUrl = `https://metadata.y00ts.com/y/${metadataIndex}.json`;

        try {
            console.log(`Fetching metadata: ${metadataUrl}`);
            const response = await fetch(metadataUrl, { signal });

            if (!response.ok) {
                 throw new Error(`FAILED TO FETCH Y00T DATA. STATUS: ${response.status}`);
            }
            const metadata = await response.json();
            lastFetchedMetadata = metadata; // Store metadata

            if (signal.aborted) {
                console.log("Metadata fetch aborted after receiving response, before image load.");
                return;
            }

            if (metadata && metadata.image) {
                imageStackContainer.style.display = 'block'; // Show container for image
                const nftLoadIdRef = { id: currentNftImageLoadId };

                loadImageAsBlob(
                    nftImage,
                    metadata.image,
                    `y00t NFT #${id}`,
                    nftLoadIdRef,
                    () => { // Success callback for NFT image
                        if (signal.aborted) return;
                        currentNftImageLoadId = nftLoadIdRef.id; // Update global ID
                        console.log(`y00t Image #${id} loaded successfully via blob.`);
                        loadingDiv.style.display = 'none';
                        downloadBtn.style.display = 'block';
                        updateCigarVisibility(); // This will then try to load cigar if needed
                    },
                    () => { // Error callback for NFT image
                        if (signal.aborted) return;
                        console.error(`Failed to load main y00t image for #${id} from ${metadata.image}`);
                        loadingDiv.style.display = 'none';
                        errorDiv.textContent = 'FAILED TO LOAD MAIN NFT IMAGE.';
                        clearFetchedDataUI(true);
                    }
                );

            } else {
                throw new Error('INVALID METADATA FORMAT OR "IMAGE" FIELD NOT FOUND.');
            }

        } catch (err) {
            if (err.name === 'AbortError') {
                console.log(`Fetch for y00t ID ${idValueTrimmed} was aborted.`);
                // Only clear to preview if no new search has started and no image is displayed
                if (imageStackContainer.style.display === 'none' && !y00tIdInput.value.trim()) {
                     clearFetchedDataUI(true);
                }
                loadingDiv.style.display = 'none';
            } else {
                console.error("Error fetching y00t:", err);
                errorDiv.textContent = `AN ERROR OCCURRED: ${err.message.toUpperCase()}`;
                clearFetchedDataUI(true);
                loadingDiv.style.display = 'none';
            }
        } finally {
            if (currentFetchController && currentFetchController.signal === signal) {
                currentFetchController = null;
            }
        }
    }

    async function handleDownload() {
        // Check if nftImage has a blob src and is loaded
        if (!lastFetchedMetadata || !nftImage.src.startsWith('blob:') || imageStackContainer.style.display === 'none' || !nftImage.complete || nftImage.naturalWidth === 0) {
            alert("ACTUAL NFT IMAGE NOT FULLY LOADED OR UNAVAILABLE FOR DOWNLOAD.");
            return;
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const TARGET_WIDTH = 1000;
        const TARGET_HEIGHT = 1000;
        canvas.width = TARGET_WIDTH;
        canvas.height = TARGET_HEIGHT;

        const idForFilename = y00tIdInput.value || 'NFT';

        // This function now directly uses the image elements.
        // Since their src is a blob URL, they are effectively same-origin for canvas.
        const drawImageToCanvas = (imgElement) => {
            return new Promise((resolve) => {
                // Check if the image is visible and loaded (blob URLs should be considered loaded if complete)
                if (imgElement.style.display !== 'none' && imgElement.complete && imgElement.naturalWidth > 0 && imgElement.src.startsWith('blob:')) {
                    const hRatio = TARGET_WIDTH / imgElement.naturalWidth;
                    const vRatio = TARGET_HEIGHT / imgElement.naturalHeight;
                    const ratio = Math.min(hRatio, vRatio);
                    const scaledWidth = imgElement.naturalWidth * ratio;
                    const scaledHeight = imgElement.naturalHeight * ratio;
                    const offsetX = (TARGET_WIDTH - scaledWidth) / 2;
                    const offsetY = (TARGET_HEIGHT - scaledHeight) / 2;
                    ctx.drawImage(imgElement, offsetX, offsetY, scaledWidth, scaledHeight);
                    resolve();
                } else {
                     console.warn(`Image ${imgElement.id || imgElement.alt} not ready for canvas draw or not a blob.`);
                    resolve(); // Resolve anyway to not block download
                }
            });
        };

        let filenameParts = [`Y00T_${idForFilename}`];

        try {
            await drawImageToCanvas(nftImage);

            if (showCigar && cigarOverlayImage.src.startsWith('blob:')) {
                await drawImageToCanvas(cigarOverlayImage);
                if (cigarOverlayImage.style.display !== 'none' && cigarOverlayImage.src) {
                    filenameParts.push("CIGAR");
                }
            }

            filenameParts.push(`${TARGET_WIDTH}X${TARGET_HEIGHT}.PNG`);
            const finalFilename = filenameParts.join('_').replace(/__+/g, '_');

            triggerCanvasDownload(canvas, finalFilename);

        } catch (e) {
            console.error("ERROR DURING IMAGE COMPOSITING FOR DOWNLOAD:", e);
            alert("AN ERROR OCCURRED WHILE PREPARING THE IMAGE FOR DOWNLOAD. CHECK CONSOLE FOR DETAILS.");
        }
    }

    function triggerCanvasDownload(canvas, filename) {
         try {
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (e) {
            console.error("ERROR CREATING DATA URL OR DOWNLOADING:", e);
            alert("FAILED TO CREATE IMAGE FOR DOWNLOAD. THIS CAN SOMETIMES HAPPEN DUE TO BROWSER SECURITY RESTRICTIONS.");
        }
    }

    // --- Initial Setup ---
    function initializeApp() {
        const headerLoadIdRef = { id: currentHeaderImageLoadId };
        loadImageAsBlob(
            headerImage,
            HEADER_IMAGE_URL,
            "Y00TS NFT FINDER HEADER",
            headerLoadIdRef,
            () => { currentHeaderImageLoadId = headerLoadIdRef.id; },
            () => { headerImage.alt = "Header image failed to load"; }
        );
        resetSearch(); // This will load the preview image
        console.log("y00ts Finder Initialized.");
    }

    initializeApp();

</script>
</body>
</html>
